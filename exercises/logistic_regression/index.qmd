---
title: "Logistic GLMs: mite responses to water"
format: html
editor_options: 
  chunk_output_type: console
---

We've already looked at univariate models. When we fit the same model to multiple different groups, we don't expect the same values for all the coefficients. Each unit in our experiment we are studying will respond to the same variable in different ways.

Hierarchical models represent a way to *model* this variation, in ways that range from simple to complex.

Before we dive in with hierarchical structure, let's build a bridge between these two approaches.

This is useful to help us understand what a hierarchical model does.

However it is also useful from a strict model-building perspective -- so useful that [Andrew Gelman calls it a "Secret Weapon"](https://statmodeling.stat.columbia.edu/2005/03/07/the_secret_weap/)

## Loading models and data

```{r setup}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(rstanarm))
library(tidybayes)

data(mite, package = "vegan")
data("mite.env", package = "vegan")
data("mite.xy", package = "vegan")
```

And some quick data restructuring to combine both.

```{r datasetup}
# combine data and environment
mite_data_long <- bind_cols(mite.env, mite) |> 
  pivot_longer(Brachy:Trimalc2, names_to = "spp", values_to = "abd")
```

To keep things simple and univariate, let's consider only water concentration as an independent variable.

First, a quick word about centering and scaling a predictor variable:

1.  I center the predictor by subtracting the mean. This changes the *intercept* of my linear predictor. it becomes the mean log-odds of occurrance when the water content is average
2.  I divide water content by 100. The dataset has units of **grams per Litre** of water (see `?vegan::mite.env` for more details). This is fine, but I don't think mites are able to sense differences as precise as a millimeter of water either way. by dividing by 10 I transform this into centilitres, which is more informative.

```{r smoothglm}
mite_data_long_transformed <- mite_data_long |> 
  mutate(presabs = as.numeric(abd>0),
         # center predictors
         water = (WatrCont - mean(WatrCont)) / 100
         )

mite_data_long_transformed |> 
  ggplot(aes(x = water, y = presabs)) + 
  geom_point() + 
  stat_smooth(method = "glm", method.args = list(family = "binomial")) + 
  facet_wrap(~spp)
```

some things to notice about this figure:

-   the x-axis scale has been transformed from "grams per litre" to "centilitres away from average
-   there is a ton of variation in how different species respond to water!

```{r make_mite_glms}
mite_many_glms <- mite_data_long_transformed |> 
  nest_by(spp) |> 
  mutate(logistic_regressions = list(
    glm(presabs ~ water,
        family = "binomial",
        data = data))) |> 
  mutate(coefs = list(broom::tidy(logistic_regressions)))




mite_many_glms <- mite_data_long_transformed |> 
  nest_by(spp) |> 
  mutate(logistic_regressions = list(
    glm(presabs ~ 1 + water, 
        family = binomial(link = "logit"),
        data = data)
  )) |> 
  mutate(coefs = list(broom::tidy(logistic_regressions)))

broom::tidy(mite_many_glms$logistic_regressions[[5]])
broom::glance(mite_many_glms$logistic_regressions[[5]])

mite_many_glms$coefs[[5]]



```

::: callout-note
## Split-Apply-Combine

To explore this kind of thinking, we are going to use an approach sometimes called ["split-apply-combine"](https://vita.had.co.nz/papers/plyr.pdf)

There are many possible ways to do this in practice. We are using a technique here from the tidyverse, which you can [read more about](https://dplyr.tidyverse.org/articles/rowwise.html).
:::

```{r coef_plot}
mite_many_glm_coefs <- mite_many_glms |> 
  select(-data, -logistic_regressions) |> 
  unnest(coefs)

mite_many_glm_coefs |> 
  ggplot(aes(x = estimate, y = spp,
             xmin = estimate - std.error,
             xmax = estimate + std.error)) + 
  geom_pointrange() + 
  facet_wrap(~term, scales = "free")
```

As you can see, some of these estimates are high, others low. We could also plot these as histograms to see this distribution.

```{r secretweapon_hist}
mite_many_glm_coefs |> 
  ggplot(aes(x = estimate)) + 
  geom_histogram(binwidth = .5) + 
  facet_wrap(~term, scales = "free")
```

Once again, the two parameters of this model represent:

-   *Intercept* The probability (in log-odds) of a species being present at the average water concentration. some species are common, others are rare.
-   *water* this is the change in probability (in log-odds) as water increases by one centilitre per litre of substrate.


## Modelling multiple slopes in rstanarm

```{r}
mite_data_long_transformed |> glimpse()

mite_slopes_corr_stan <- stan_glmer(
  presabs ~ 1 + water + (1 + water | spp), 
  family = binomial(link = "logit"),
  data = mite_data_long_transformed,
  
  # priors 
  prior = normal(0, .2),
  prior_intercept = normal(-.2, .5),
  prior_covariance = decov(
    regularization = 2,
    concentration = 1, 
    shape = .4, 
    scale = 1),
    
  chains = 4,
  cores = 4, 
  iter = 2000,
  refresh = 0
)

summary(mite_slopes_corr_stan)
```

The code in `rstanarm` calls for a particular way to define the prior for the slopes and intercepts

```{r}
curve(dgamma(x, shape = .4, scale = 7), xlim = c(0, 5))

mean(rgamma(5000, shape = .4, scale = 1))
```

plot it on the data:

```{r}
predicted_mite_curves <- mite_data_long_transformed |> 
  modelr::data_grid(
    water = modelr::seq_range(water, n = 20) ,
    spp = spp #head(spp)
  ) |> 
  add_epred_rvars(mite_slopes_corr_stan)

predicted_mite_curves |> 
  ggplot(aes(x = water, ydist = .epred)) + 
  tidybayes::stat_lineribbon() + 
  facet_wrap(~spp)
```

## Comparing slopes from fixed and hierarchical models

Let's extract the coefficients from both fixed and hierarchical models and see what they tell us about regularization.

First, fix a simple model with no hierarchy on the slopes or intercepts

```{r}
mite_slopes_simple_stan <- stan_glm(
  presabs ~ 1 + water + spp + water:spp,
  family = binomial(link = "logit"),
  data = mite_data_long_transformed,
  
  # priors 
  prior = normal(0, 5),
  prior_intercept = normal(-.2, .5),
    
  chains = 4,
  cores = 4,
  iter = 2000,
  refresh = 0
)

summary(mite_slopes_simple_stan)
```

## Looking at regularization

One of the main reasons to use hierarchical models is regularization. This brings coefficients closer to the overall average of the model. This effect is greater for more extreme parameter estimates, and for those estimated from smaller sample sizes. 

Why is this good? Because we want to make inferences about the _regular_ features of a sample, ie those that are likely to be repeated in the future. Extreme and uncertain events are unlikely to be seen again, by definition.  This kind of regularization always leads to better predictions for new data outside our sample. 

This code is long, and not necessarily meant to be reused. However, it shows a process that might be useful in your own work: calculating species-specific slopes. 

```{r}
# get_variables(mite_slopes_simple_stan)

## Simple model
model_posterior <- mite_slopes_simple_stan |> 
  posterior::as_draws_rvars() |> 
  enframe(name = "term", value = "draws") |> 
  unnest(draws)

water_firstspp <- model_posterior |> 
  filter(term == "water") |> 
  rename(main_effect = term, main_post = draws)

water_firstspp

water_interactions <- model_posterior |> 
  filter(str_detect(term, "water:"))

simple_slopes <- bind_cols(water_firstspp, water_interactions) |> 
  mutate(slope = draws + main_post,
         term = str_replace(term, "water:spp", "")) |> 
  select(species = term, slope) |> 
  mutate(model = "simple", .before = "species")

## add back in the very first species, Brachy, which was defined as the intercept
simple_slopes <- simple_slopes |> 
  bind_rows(
    tibble(model = "simple",
           species = "Brachy",
           slope = water_firstspp$main_post)
  )


## Hierarchical model
# get_variables(mite_slopes_corr_stan)
hier_slopes <- mite_slopes_corr_stan |> 
  spread_rvars(water, b[spp]) |> 
  filter(str_detect(spp,"water")) |> 
  mutate(species=str_replace(spp, "water spp:", ""),
         slope = water + b) |> 
  select(species, slope) |> 
  mutate(model = "hierarchical", .before = "species")

bind_rows(simple_slopes, hier_slopes) |> 
  ggplot(aes(x = species, ydist = slope, col = model)) + 
  stat_pointinterval(position = position_dodge(width = .4)) + 
  coord_flip()
```



## Posterior calculations:  species richness

Everything calculated with posterior samples is also part of the posterior distribution. Its' possible to calculate multiple things out of this model. For example, if we add together the predicted species richness at each site, we can draw the curve for how species richness might be expected to vary across this water gradient.

```{r}
predicted_mite_curves |> 
  pivot_wider(names_from = spp, values_from = .epred) |> 
  nest_by(water) |> 
  mutate(S = Reduce(`+`, data)) |> 
  ggplot(aes(x = water, ydist = S)) + 
  stat_lineribbon()
  
```

## Comparison to lme4 

```{r}
library(lme4)
mite_water_lmer <- glmer(presabs ~ 1 + water + (1 + water | spp), 
  family = binomial(link = "logit"),
  data = mite_data_long_transformed,)

summary(mite_water_lmer)
```
