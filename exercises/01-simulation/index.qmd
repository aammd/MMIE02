---
title: "Introduction to Simulation for validating a model"
description: |
  simulating, checking and understanding a simple model.
execute:
  freeze: true
comments:
  hypothesis: false
format:
  html:
    code-tools: true
editor_options: 
  chunk_output_type: console
---

```{r, message=FALSE}
library(tidyverse)
library(lme4)
library(rstanarm)
```

::: callout-tip
## Goals of this lesson

1.  Introduce the idea of a generative model
2.  Using generated data to validate a model
4.  Outline of a Bayesian workflow
1.  Introduction 
:::

### The process

To practice our first model, we'll being with an imaginary example. We'll imagine we're conducting a particularly pleasant study: counting birds!

**Question** How many birds will each person in the class find? For the purposes of this example, let's say there are 22 people.

1.  We're going to count birds, so we'll have count data: a number that is either 0 or some positive, round number
2.  We'll make a simplifying assumption: everybody has the same chance of seeing a bird (i.e. no differences in skill or equipment), and everyone in the class is an independent observer (i.e. nobody is working in pairs, etc.)
3.  Everyone in the class makes only one count, so we have 22 numbers.

We're Bayesian, so we need to write a probability distribution for all the possible values.

$$
\begin{align}
\text{Number of Birds}_{\text{seen by person i}} &\sim \text{Poisson}(\lambda) \\
\lambda &\sim \text{Uniform}(0, 60)
\end{align}
$$

A quick note about notation for models like these:

-   We use a subscript $i$ to indicate the "label" for each observation in our dataset. You can think of this as the row number of the data spreadsheet, and imagine sliding your finger down the column of measurements, modelling each value in turn.
-   Usually we'll use more general language, such as $y_i$. But for this simple example I wanted to make things as explicit as possible.
-   Notice the symbol $\sim$. This is read as "distributed as", and indicates the probability distribution from which the values might come. When the values we're talking about are data that we can observe (in this case, counts of birds), we call the distribution the likelihood. When the value is something we can't observe (in this case, the average count $\lambda$) we call the distribution the prior.

<aside>Remember that measuring uncertainty with probability is what makes thinking Bayesian. That means we need a probability distribution for everything we can't observe (like an average) or haven't seen yet (like observations)</aside>

::: callout-warning
We'll be talking about better ways to model count data in a later exercise! For now, I'm using the Uniform distribution for simplicity. It's not usually a very good choice!
:::

### Simulation in R

Before starting work on real data, we are going to begin by learning how to generate data by simulation. There are at least three reasons why this is a good idea:

1.  **Understand your priors.**. For most interesting models in ecology, you will not be able to pick good numbers for your prior parameters just by thinking hard. Should the prior on annual tree growth be $\text{Normal}(2, 1)$ ? Or should the standard deviation be bigger? Smaller? As we'll see, simulation will demystify the process.
2.  **Validate your model.** Bayesian models are great because they can create datasets by simulation. This suggests a very minimum requirement we might have for a statistical model: use known parameters and a model to generate data, then fit that same model to the very data it generated, and see if we get back something close to those known parameter values.
3.  **Test your understanding.** Perhaps most importantly, simulation helps you to test your own intuition. If you can simulate data from your model, then you really understand it! If you can't, then you don't know quite how it works yet. It's rare[^1] that a biologist will fail to learn something by simulating a dataset.

[^1]: in Andrew's experience anyway!

## Simple exercise in simulation

Let's imagine we are taking a walk as a group today at this beautiful field site. What is the number of birds (total abundance of ALL species) each of us is going to see on our hike?

### Some questions to ask about simulated data

1.  What kind of observations are you going to make? Do they have a minimum or maximum value? Are they integers, or are they decimal numbers, or something else?
2.  Where do the numbers come from? This could be anything, from simple linear approximations (i.e. the models we're looking at in this course) to ODEs, mathematical models, GAMs, etc.
3.  How many observations will we be making?

One of the most useful traits of Bayesian models is that they are *generative*: they can be used to make a simulated dataset. We'll do that now for our bird example.

let's simulate from a Poisson distribution:

```{r, collapse=TRUE}
set.seed(525600)
n_people <- 21
avg_birds_per_person <- runif(1, min = 0, max = 30)
bird_count <- rpois(n_people, lambda = avg_birds_per_person)
```

Some things to note in the code above:

Every statistical distribution that is in R (which is a lot! almost all! ) has four different functions. If the distribution is called `dist`, then they are:

-   `rdist` = draw random numbers from `dist`
-   `qdist` = the quantile function -- what value gives a certain proportion of the distribution?
-   `pdist` = the probability density function -- what proportion of the distribution is below a certain value?
-   `ddist` the density function = draws the "shape" of a distribution. How probable are specific values?

The other thing to note is that there are TWO simulation steps here: **first**, simulating a value of the average ($\lambda$) and **second**, simulating observations. In our model, the Uniform distribution was referred to as the *prior*, and the Poisson distribution was referred to as a *likelihood*, but here you can see that they are very nearly the same thing: just statements about what distribution of values might be most consistent with the data.

#### Plotting the result

Let's take a look at our simulated values:

```{r}
#| fig-cap: Histogram of simulated counts of birds

hist(bird_count, col = "lightblue", xlim = c(0, 50))
```

This is pretty great, and represents one possible realization of sampling. However, one sample isn't enough to tell us about what our $\text{Uniform}(0, 60)$ prior really means.

::: callout-tip
### EXERCISE

Try to make many different simulations (say, 12 simulations). This represents 12 different repeats of the whole process: draw a value from the uniform prior, THEN draw a value from the poisson. Visualize them any way you want! (the worked example below uses `ggplot2`)
:::

::: {.callout-note collapse="true"}
### SOLUTION

```{r}
#| fig-cap: Twelve different simulations of a possible bird dataset. Do all of these seem plausible? 

set.seed(525600)

simulate_some_birds <- function() {
  lambda <- runif(1, min = 0, max = 60)
  tibble(birds_seen = rpois(23, lambda = lambda),
         lambda = lambda)
}

bird_simulations <- purrr::map(1:12, function(x) simulate_some_birds()) |> 
  list_rbind(names_to = "simulation_id")
  

bird_simulations |> 
  ggplot(aes(x = birds_seen)) + 
  geom_histogram(bins = 28) + 
  facet_wrap(~simulation_id) + 
  theme_bw() + 
  labs(x = "Number of birds observed per person")
```
:::

This figure shows different simulations of what, according to our prior, might be reasonable datasets for us to study. Do any of them seem implausible to you? If so, try changing the prior. The goal is to make fake datasets that *seem* plausible, but which still include the possibility of some surprising observations.

When you have a prior that generates observations that cover a range of scientifically reasonable values, then you are ready to move on to fitting real data.


And then translate it into `rstanarm`.

### The model formula

Both `lme4` and `rstanarm` use the same classic R formula syntax: 

``` r
birds_seen ~ 1
```

We're using ` ~ 1 ` because our model is very simple, requiring only an intercept. 

Because it is a Poisson distribution, we also specify the response distribution here, via the `family` argument.

### rstanarm code for prior simulation

```{r}
## make the dataset
bird_simulation <- data.frame(bird_count = bird_count)

bird_model <- stan_glm(bird_count ~ 1, 
                       family = poisson(link = "identity"),
                       data = bird_simulation,
                       refresh = 0L,
                       ## PRIOR ONLY
                       prior_PD = TRUE,
                       prior_intercept = normal(location = 30, scale = 10)
)

bird_model

prior_summary(bird_model)
```


### Sampling a prior in `rstanarm`

Simulating from a prior is so essential that many Bayesian tools allow you to do this directly. 

When we run `stan_glm`, with `prior_PD = TRUE`, we sample **only** from the prior. This generates a large number of simulated datasets -- the default is 4000! Each time the model samples, it draws a new value for the unobserved average (`avg_birds_per_person`) and then 22 values for the number of birds seen by each person.

Let's pull out just a few of these datasets and visualize them.

We'll use a wonderful package called [`tidybayes`](http://mjskay.github.io/tidybayes/) to easily extract posterior draws from the result of rstanarm.

```{r}
#| fig-cap: Prior simulations of bird observations
#| 
bird_counts_simulated <- tidybayes::add_predicted_draws(
  bird_simulation, 
  bird_model)

library(tidybayes)

bird_counts_simulated |> 
  ungroup() |> 
  filter(.draw %in% sample(1:4000, replace = FALSE, size = 16)) |>   
  ggplot(aes(x = .prediction)) + 
  geom_dotplot() + 
  facet_wrap(~.draw)

```


## Parameter recovery

Let's go back and look at the fake datasets we created in R

```{r}
avg_birds_per_person
bird_count
```

and let's see if we can recapture the only known parameter, `avg_birds_per_person`, which is equal to `r avg_birds_per_person`.

We'll do it first in R, using the function `fitdistr` from the `MASS` package:

```{r}
MASS::fitdistr(bird_count, dpois, start = list(lambda=10))
```

This could also be done with `glm`

```{r}
bird_glm <- glm(bird_count ~ 1, family = "poisson")
exp(coef(bird_glm))
```

You can see that in all cases we are getting close to the value of `avg_birds_per_person`, which in these simulations is the true value.

## Parameter recovery in `rstanarm` -- sampling the posterior

Time for the [HMC Slides!](slides/03_Stan)

::: callout-tip
### EXERCISE: parameter recovery in Stan

Use the Stan code above to fit the model to our simulated data. Do we recover the parameters? That is, rerun the example above but change the `prior_PD` argument to "`FALSE`"


::: {.callout-note collapse="true"}
### SOLUTION

the `brms` syntax is only slightly changed! note the different filename and the different object name as well:

```{r}
bird_posterior <- stan_glm(bird_count ~ 1, 
                       family = poisson(link = "identity"),
                       data = bird_simulation,
                       refresh = 0L,
                       ## PRIOR ONLY
                       prior_PD = FALSE,
                       prior_intercept = normal(location = 30, scale = 10)
)

summary(bird_posterior)
```
:::

:::

## Visualize everything!

Bayesian workflows are highly visual. Make as many plots as you can: of your parameters, your predictions, the performance of your chains, etc.

Another essential package for working with posterior samples is called [`bayesplot`](http://mc-stan.org/bayesplot/). Let's use it to compare the posterior and prior distribution for the intercept.

```{r}
#| fig-cap: posterior distribution for `avg_birds_per_person`. The orange line is the true parameter value, which we simulated in R.

# tidybayes::get_variables(bird_posterior)

bayesplot::mcmc_areas(bird_posterior) + 
  geom_vline(xintercept = avg_birds_per_person, col = "orange", lwd = 2)
```

#### Posterior predictive checks

Bayesian models MAKE data, which suggests a clear way to validate our models: ask the model to make some data, then see how well these data correspond to biology (e.g. to our real data). Here, we will take 50 fake datasets of bird counts and compare them to the simulation we first did in R.

The process involves a bit of fiddling around in R to get the simulated data, but then `bayesplot` does all the work:

```{r}
rstanarm::pp_check(bird_posterior, plotfun = "dens_overlay")
```

### Shinystan

```{r, eval=FALSE}
shinystan::launch_shinystan(bird_posterior)
```

## Exercises

#### Level 1

-   What would you do next to add complexity the bird-counting model above?
-   We plotted histograms to evaluate our model. Experiment with other types of plots. For example, what is the maximum value in each posterior simulation? What is the minimum? How to these compare to the real data? TIP: check out `` ?bayesplot::`PPC-overview` ``

#### Level 2

-   Try to fit YOUR data to this model!. Check to see if the distribution you chose is implemented in Stan -- see, for example, [this list](https://mc-stan.org/docs/functions-reference/binary_distributions.html).
-   Check your model using the plots we have already seen today.

#### Level 3

-   You would never actually do the analysis in this exercise! If all you want is the average of a Poisson distribution, you can get that without any sampling at all. Start by writing the model with a different prior:

$$
\begin{align}
\text{Number of Birds}_{\text{seen by person i}} &\sim \text{Poisson}(\lambda) \\
\lambda &\sim \text{Gamma}(9, .5)
\end{align}
$$

This lets us calculate the posterior distribution directly. See the equation [on Wikipedia](https://en.wikipedia.org/wiki/Poisson_distribution#Bayesian_inference) and calculate the posterior for our bird data.


