{
  "hash": "77b5f056ab73f650f62fc295fb30316f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Univariate regression\"\ndescription: |\n  The shortest route to science is a straight line.\nexecute:\n  freeze: true\ncomments:\n  hypothesis: true\nformat:\n  html:\n    code-tools: true\neditor_options: \n  chunk_output_type: console\n---\n\n## Load packages and data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nsuppressPackageStartupMessages(library(dplyr))\nlibrary(tidybayes)\nsuppressPackageStartupMessages(library(rstanarm))\n```\n:::\n\n\n## Statistical models of Penguin bill morphology.\n\nWe'll be studying the relationship between two numbers about penguin bills. Specifically, we'll ask **\"Are longer bills also deeper?\"**. This question might not be the most interesting ecologically, but it is a great chance to practice some interesting stats.\n\nLet's begin with plotting the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  ggplot(aes(x = bill_len, y = bill_dep)) + \n  geom_point() + \n  stat_smooth(method = \"lm\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 2 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 2 rows containing missing values or values outside the scale range\n(`geom_point()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![Bill depth (mm) as predicted by bill length (mm) across the entire `palmerpenguins` dataset.](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nLet's write a simple statistical model for these data:\n\n$$\n\\begin{align}\n\\text{Bill depth}_i &\\sim \\text{Normal}(\\mu_i, \\sigma) \\\\\n\\mu_i &= \\beta_0 + \\beta_1\\times\\text{Bill length}_i \\\\\n\\beta_0 &\\sim \\text{Normal}(??) \\\\\n\\beta_1 &\\sim \\text{Normal}(??) \\\\\n\\sigma &\\sim \\text{Exponential}(??)\n\\end{align}\n$$\n\nWhat should our priors be? Before we can answer that, we have a more important question:\n\n::: callout-warning\n# WHERE IS ZERO??\n\nIt has to be somewhere. Does it make sense? take control and choose for yourself.\n:::\n\nIf we fit a model like this **without** thinking about the location of zero, we get some pretty silly answers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoef(lm(bill_dep ~ bill_len, data = penguins))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept)    bill_len \n20.88546832 -0.08502128 \n```\n\n\n:::\n:::\n\n\nWhen the value of bill length is 0, the average of the response is the intercept:\n\n$$\n\\begin{align}\n\\mu_i &= \\beta_0 + \\beta_1\\times\\text{Bill length}_i \\\\\n\\mu_i &= \\beta_0 + \\beta_1\\times0 \\\\\n\\mu_i &= \\beta_0 \\\\\n\\end{align}\n$$\n\nBut, if we take the data as we found it, we're going to be talking about $\\beta_0$ as the depth of a penguin's bill *when the bill has 0 length!* Clearly that isn't a very meaningful value. From the point of view of setting priors and interpreting coefficients, it helps a lot to set a meaningful 0.\n\nA very common choice is to **subtract the average** from your independent variable, so that penguins with an average bill length now have an average of 0:\n\n$$\n\\begin{align}\n\\text{Bill depth}_i &\\sim \\text{Normal}(\\mu_i, \\sigma) \\\\\n\\mu_i &= \\beta_0 + \\beta_1\\times(\\text{Bill length}_i  - \\overline{\\text{Bill length}})\\\\\n\\beta_0 &\\sim \\text{Normal}(??) \\\\\n\\beta_1 &\\sim \\text{Normal}(??)\n\\end{align}\n$$\n\nNow $\\beta_0$ means the average *bill depth* at the average *bill length*. It becomes easier to think about priors:\n\n$$\n\\begin{align}\n\\text{Bill depth}_i &\\sim \\text{Normal}(\\mu_i, \\sigma) \\\\\n\\mu_i &= \\beta_0 + \\beta_1\\times(\\text{Bill length}_i  - \\overline{\\text{Bill length}})\\\\\n\\beta_0 &\\sim \\text{Normal}(17,2) \\\\\n\\beta_1 &\\sim \\text{Normal}(0,.5) \\\\\n\\sigma &\\sim \\text{Exponential}(0.5)\n\\end{align}\n$$\n\n::: callout-note\n## Exercise\n\nWhat continuous predictors have you used in your analysis? How would you find a biologically meaningful zero? Think about how you would center time, age, mass, fitness etc.\n:::\n\n## Prior predictive simulations\n\nArmed with this model, it becomes much easier to think about prior predictions.\n\nWe'll make a bunch of lines implied by the equation above. There's two steps:\n\n1.  Center the predictor\n2.  Make up a vector that goes from the minimum to the maximum of the predictor. This is just for convenience!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbill_len_centered <- with(penguins,\n                          bill_len - mean(bill_len,\n                                                na.rm = TRUE))\n\n## make up a short vector\nsome_bill_lengths <- seq(\n  from = min(bill_len_centered, na.rm = TRUE), \n  to = max(bill_len_centered, na.rm = TRUE),\n  length.out = 10\n  )\n```\n:::\n\n\n::: callout-warning\n## Shortcuts to these common tasks\n\nThese tasks are so common that they are automated in helper functions.\n\nFor centering predictors, see the base R function `?scale` (however, doing this by hand is often more convenient)\n\nFor creating a short vector over the range of a predictor, see `modelr::seq_range`. The R package [`modelr`](https://modelr.tidyverse.org/) has many different functions to help with modelling.\n:::\n\nTo simulate, we'll use some matrix algebra, as we saw in lecture:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslopes <- rnorm(7, 0, .5)\ninters <- rnorm(7, 17, 2)\n\nX <- cbind(1, some_bill_lengths)\nB <- rbind(inters, slopes)\n\nknitr::kable(head(X))\n```\n\n::: {.cell-output-display}\n\n\n|   | some_bill_lengths|\n|--:|-----------------:|\n|  1|       -11.8219298|\n|  1|        -8.7663743|\n|  1|        -5.7108187|\n|  1|        -2.6552632|\n|  1|         0.4002924|\n|  1|         3.4558480|\n\n\n:::\n\n```{.r .cell-code}\nknitr::kable(head(B))\n```\n\n::: {.cell-output-display}\n\n\n|       |           |           |           |           |          |           |           |\n|:------|----------:|----------:|----------:|----------:|---------:|----------:|----------:|\n|inters | 15.5371199| 19.1658140| 16.8749622| 14.8732681| 13.493175| 18.6040575| 17.2760168|\n|slopes |  0.2915136| -0.5075052|  0.3472609| -0.8665946| -1.097236| -0.0070939|  0.3765543|\n\n\n:::\n\n```{.r .cell-code}\nprior_mus <- X %*% B\n\nmatplot(x = some_bill_lengths,\n        y = prior_mus, type = \"l\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n::: callout-note\n## Exercise\n\nCopy the code above. Increase the number of simulations. Which priors are too wide? Which are too narrow?\n:::\n\n### Simulating Observations\n\nThere are always at least TWO kinds of predictions we can be thinking about:\n\n1.  Predicted averages. This is often called a \"confidence\" interval for a regression line.\n2.  Predicted observations. This is often called a \"prediction\" interval.\n\nWe can use the full model to simulate observations!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nslopes <- rnorm(7, 0, .5)\ninters <- rnorm(7, 17, 2)\nsigmas <- rexp(7, rate = 0.3)\n\nX <- cbind(1, some_bill_lengths)\nB <- rbind(inters, slopes)\n\nprior_mus <- X %*% B\n\nprior_obs <- matrix(0, nrow = nrow(prior_mus), ncol = ncol(prior_mus))\n\nfor (j in 1:ncol(prior_obs)) {\n  prior_obs[,j] <- rnorm(n = nrow(prior_mus),\n                         mean = prior_mus[,j],\n                         sd = sigmas[j])\n}\n\nmatplot(x = some_bill_lengths,\n        y = prior_obs, type = \"p\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nTidyverse style for those who indulge:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  sim_id = 1:7,\n  slopes = rnorm(7, 0, .5),\n  inters = rnorm(7, 17, 2),\n  sigmas = rexp(7, rate = 0.2)\n  ) |> \n  mutate(x = list(seq(from = -10, to = 10, length.out = 6))) |> \n  rowwise() |> \n  mutate(avg = list(x * slopes + inters),\n         obs = list(rnorm(length(avg), mean = avg, sd = sigmas)),\n         sim_id = as.factor(sim_id)) |> \n  tidyr::unnest(cols = c(\"x\", \"avg\", \"obs\")) |> \n  ggplot(aes(x= x, y = avg, group = sim_id, fill = sim_id)) + \n  geom_line(aes(colour = sim_id)) + \n  geom_point(aes(y = obs, fill = sim_id), pch = 21, size = 3) + \n  scale_fill_brewer(type = \"qual\") + \n  scale_colour_brewer(type = \"qual\") + \n  facet_wrap(~sim_id)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n::: callout-tip\n### EXERCISE\n\nPick one of the two simulations above and modify it. Here are some suggested modifications:\n\n-   Experiment with priors that are \"too narrow\" or \"too wide\".\n-   Try a different distribution than the one used\n-   Instead of bill size, imagine that we are applying this model to YOUR data. What would you change?\n:::\n\n## Linear regression in rstanarm\n\nNow we write some rstanarm code for this model. We'll begin with a simple model that has no posterior predictions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## get data ready\npeng_dep_len_df <- penguins |> \n  tidyr::drop_na(bill_dep, bill_len) |> \n  mutate(bill_len_cen = bill_len - mean(bill_len))\n\n## fit model with rstanarm\nnormal_reg_stan <- stan_glm(\n  bill_dep ~ 1 + bill_len_cen,\n  data = peng_dep_len_df,\n  family = gaussian(),\n\n  # priors\n  prior = normal(0, 0.5),          # slope (bill_len_cen)\n  prior_intercept = normal(17, 2), # intercept\n  prior_aux = exponential(0.5),    # sigma\n\n  chains = 4,\n  iter = 2000,\n  refresh = 0,\n  seed = 525600\n)\n\nnormal_reg_stan\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nstan_glm\n family:       gaussian [identity]\n formula:      bill_dep ~ 1 + bill_len_cen\n observations: 342\n predictors:   2\n------\n             Median MAD_SD\n(Intercept)  17.1    0.1  \nbill_len_cen -0.1    0.0  \n\nAuxiliary parameter(s):\n      Median MAD_SD\nsigma 1.9    0.1   \n\n------\n* For help interpreting the printed output see ?print.stanreg\n* For info on the priors used see ?prior_summary.stanreg\n```\n\n\n:::\n:::\n\n\nget the variable names, which will show us the names of parameters we can plot later:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidybayes::get_variables(normal_reg_stan)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"(Intercept)\"   \"bill_len_cen\"  \"sigma\"         \"accept_stat__\"\n[5] \"stepsize__\"    \"treedepth__\"   \"n_leapfrog__\"  \"divergent__\"  \n[9] \"energy__\"     \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormal_reg_stan |> \n  bayesplot::mcmc_areas(pars = c(\"bill_len_cen\", \"(Intercept)\", \"sigma\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n\n```{.r .cell-code}\np <- normal_reg_stan |> \n  bayesplot::mcmc_areas(pars = \"bill_len_cen\") + \n  coord_cartesian(xlim = c(-0.16, 0.16))  \n```\n:::\n\n\n::: callout-tip\n### EXERCISE\n\n**Discussion** : Look just at the posterior distribution of the slope right above. Do we have evidence that there's a relationship between bill length and bill depth?\n:::\n\n## Posterior predictions in R\n\nWe can calculate a posterior prediction line directly in R for these data. I'll show each step in this workflow separately:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormal_reg_stan |> \n  tidybayes::spread_rvars(bill_len_cen, `(Intercept)`, sigma)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n     bill_len_cen `(Intercept)`        sigma\n       <rvar[1d]>    <rvar[1d]>   <rvar[1d]>\n1  -0.085 ± 0.019      17 ± 0.1  1.9 ± 0.073\n```\n\n\n:::\n:::\n\n\n`tidybayes` helps us extract the posterior distribution of the parameters into a convenient object called an `rvar`. Learn more about tidybayes [here](http://mjskay.github.io/tidybayes/articles/tidybayes.html) and about the rvar datatype [here](https://mc-stan.org/posterior/articles/rvar.html)\n\nNext we combine these posteriors with a vector of observations to make a posterior distribution of LINES:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormal_reg_predline <- normal_reg_stan |> \n  tidybayes::spread_rvars(bill_len_cen, `(Intercept)`) |> \n  tidyr::expand_grid(x = seq(from = -15, to = 15, length.out = 5)) |> \n  mutate(mu = `(Intercept)` + bill_len_cen*x)\n\nnormal_reg_predline\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n     bill_len_cen `(Intercept)`     x         mu\n       <rvar[1d]>    <rvar[1d]> <dbl> <rvar[1d]>\n1  -0.085 ± 0.019      17 ± 0.1 -15    18 ± 0.30\n2  -0.085 ± 0.019      17 ± 0.1  -7.5  18 ± 0.18\n3  -0.085 ± 0.019      17 ± 0.1   0    17 ± 0.10\n4  -0.085 ± 0.019      17 ± 0.1   7.5  17 ± 0.18\n5  -0.085 ± 0.019      17 ± 0.1  15    16 ± 0.31\n```\n\n\n:::\n:::\n\n\nFinally we'll plot these:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormal_reg_predline |> \n  ggplot(aes(x = x, dist = mu)) + \n  tidybayes::stat_lineribbon() + \n  geom_point(aes(x = bill_len_cen, y = bill_dep),\n             inherit.aes = FALSE,\n             data = peng_dep_len_df)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nThe above workflow makes a nice figure, but perhaps it helps to see the individual lines to understand what is happening here. We can get these with another handy function, `unnest_rvars()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormal_reg_predline |> \n  unnest_rvars() |> \n  ggplot(aes(x = x, y = mu)) + \n  # tidybayes::stat_lineribbon() +\n  geom_line(aes(group = .draw), alpha = 5/100) + \n  geom_point(aes(x = bill_len_cen, y = bill_dep),\n             inherit.aes = FALSE,\n             data = peng_dep_len_df)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n## Posterior predicted observations\n\nThere is a SECOND kind of prediction that we can make using this line. Instead of looking at the average of the line, we look at the possible observations around the line.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(bill_len_cen = seq(from = -15, to = 15, length.out = 5)) |> \n  tidybayes::add_predicted_rvars(normal_reg_stan) |> \n  ggplot(aes(x = bill_len_cen, ydist = .prediction)) + \n  stat_lineribbon() +\n  geom_point(aes(x = bill_len_cen, y = bill_dep),\n             inherit.aes = FALSE,\n             data = peng_dep_len_df) + \n  scale_fill_brewer(palette = \"Greens\", direction = -1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(normal_reg_stan)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nModel Info:\n function:     stan_glm\n family:       gaussian [identity]\n formula:      bill_dep ~ 1 + bill_len_cen\n algorithm:    sampling\n sample:       4000 (posterior sample size)\n priors:       see help('prior_summary')\n observations: 342\n predictors:   2\n\nEstimates:\n               mean   sd   10%   50%   90%\n(Intercept)  17.1    0.1 17.0  17.1  17.3 \nbill_len_cen -0.1    0.0 -0.1  -0.1  -0.1 \nsigma         1.9    0.1  1.8   1.9   2.0 \n\nFit Diagnostics:\n           mean   sd   10%   50%   90%\nmean_PPD 17.1    0.1 17.0  17.2  17.3 \n\nThe mean_ppd is the sample average posterior predictive distribution of the outcome variable (for details see help('summary.stanreg')).\n\nMCMC diagnostics\n              mcse Rhat n_eff\n(Intercept)   0.0  1.0  3798 \nbill_len_cen  0.0  1.0  3596 \nsigma         0.0  1.0  3808 \nmean_PPD      0.0  1.0  3607 \nlog-posterior 0.0  1.0  2082 \n\nFor each parameter, mcse is Monte Carlo standard error, n_eff is a crude measure of effective sample size, and Rhat is the potential scale reduction factor on split chains (at convergence Rhat=1).\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n### EXERCISE\n\nExtend this model to include species. Specifically, let each species have its own value of the `intercept`. This involves combining this regression example with the previous activity on discrete predictors.\n\nWhen you're done, look at the resulting summary of coefficients. What do you notice that's different?\n:::\n\n::: {.callout-note collapse=\"true\"}\n### SOLUTION\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## dataset\nglimpse(peng_dep_len_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 342\nColumns: 9\n$ species      <fct> Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, A…\n$ island       <fct> Torgersen, Torgersen, Torgersen, Torgersen, Torgersen, To…\n$ bill_len     <dbl> 39.1, 39.5, 40.3, 36.7, 39.3, 38.9, 39.2, 34.1, 42.0, 37.…\n$ bill_dep     <dbl> 18.7, 17.4, 18.0, 19.3, 20.6, 17.8, 19.6, 18.1, 20.2, 17.…\n$ flipper_len  <int> 181, 186, 195, 193, 190, 181, 195, 193, 190, 186, 180, 18…\n$ body_mass    <int> 3750, 3800, 3250, 3450, 3650, 3625, 4675, 3475, 4250, 330…\n$ sex          <fct> male, female, female, female, male, female, male, NA, NA,…\n$ year         <int> 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 200…\n$ bill_len_cen <dbl> -4.82193, -4.42193, -3.62193, -7.22193, -4.62193, -5.0219…\n```\n\n\n:::\n\n```{.r .cell-code}\n## fit model (rstanarm)\nbill_dep_len_sp_stan <- stan_glm(\n  bill_dep ~ 0 + bill_len_cen + species,\n  data = peng_dep_len_df,\n  family = gaussian(),\n\n  prior = normal(c(17, 17, 17, 0), c(2, 2, 2, .5)),   # bill_len_cen\n  prior_intercept = NULL,\n  prior_aux = exponential(0.5),\n\n  chains = 4,\n  iter = 2000,\n  refresh = 0,\n  seed = 525600\n)\n\nbill_dep_len_sp_stan\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nstan_glm\n family:       gaussian [identity]\n formula:      bill_dep ~ 0 + bill_len_cen + species\n observations: 342\n predictors:   4\n------\n                 Median MAD_SD\nbill_len_cen      0.3    0.0  \nspeciesAdelie    19.7    0.1  \nspeciesChinstrap 17.1    0.2  \nspeciesGentoo    13.6    0.1  \n\nAuxiliary parameter(s):\n      Median MAD_SD\nsigma 1.0    0.0   \n\n------\n* For help interpreting the printed output see ?print.stanreg\n* For info on the priors used see ?prior_summary.stanreg\n```\n\n\n:::\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidyr::expand_grid(bill_len_cen = seq(from = -15, to = 15, length.out = 5),\n                   species = unique(peng_dep_len_df$species)) |>\n  tidybayes::add_epred_rvars(bill_dep_len_sp_stan) |>\n  ggplot(aes(x = bill_len_cen, dist = .epred, group = species)) + \n  stat_dist_lineribbon() + \n  facet_wrap(~species) + \n  geom_point(aes(x = bill_len_cen, y = bill_dep), \n             data = peng_dep_len_df, inherit.aes = FALSE)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(bill_dep_len_sp_stan)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nModel Info:\n function:     stan_glm\n family:       gaussian [identity]\n formula:      bill_dep ~ 0 + bill_len_cen + species\n algorithm:    sampling\n sample:       4000 (posterior sample size)\n priors:       see help('prior_summary')\n observations: 342\n predictors:   4\n\nEstimates:\n                   mean   sd   10%   50%   90%\nbill_len_cen      0.3    0.0  0.2   0.3   0.3 \nspeciesAdelie    19.7    0.1 19.6  19.7  19.9 \nspeciesChinstrap 17.1    0.2 16.9  17.1  17.3 \nspeciesGentoo    13.6    0.1 13.4  13.6  13.7 \nsigma             1.0    0.0  1.0   1.0   1.1 \n\nFit Diagnostics:\n           mean   sd   10%   50%   90%\nmean_PPD 17.0    0.1 16.9  17.0  17.1 \n\nThe mean_ppd is the sample average posterior predictive distribution of the outcome variable (for details see help('summary.stanreg')).\n\nMCMC diagnostics\n                 mcse Rhat n_eff\nbill_len_cen     0.0  1.0  1661 \nspeciesAdelie    0.0  1.0  1746 \nspeciesChinstrap 0.0  1.0  1963 \nspeciesGentoo    0.0  1.0  1859 \nsigma            0.0  1.0  2331 \nmean_PPD         0.0  1.0  4015 \nlog-posterior    0.0  1.0  1731 \n\nFor each parameter, mcse is Monte Carlo standard error, n_eff is a crude measure of effective sample size, and Rhat is the potential scale reduction factor on split chains (at convergence Rhat=1).\n```\n\n\n:::\n:::\n\n:::\n\n<!-- ### Plotting posterior predictions -->\n\n<!-- Using `stat_lineribbon()`, let's plot the average and predicted intervals for this regression. -->\n\n<!-- ```{r} -->\n\n<!-- #| layout-ncol: 2 -->\n\n<!-- #| warning: false -->\n\n<!-- bill_posterior <- normal_reg_spp_post |>  -->\n\n<!--   tidybayes::spread_rvars(post_bill_dep_average[i], -->\n\n<!--                           post_bill_dep_obs[i]) |> -->\n\n<!--   mutate(bill_length = data_list_spp$pred_values[i], -->\n\n<!--          spp = data_list_spp$pred_spp_id) |>  -->\n\n<!--   mutate(spp = as.factor(levels(penguins$species)[spp])) -->\n\n<!-- bill_posterior |>  -->\n\n<!--   ggplot(aes(x = bill_length, -->\n\n<!--              ydist = post_bill_dep_average, -->\n\n<!--              fill = spp,  -->\n\n<!--              colour = spp)) +  -->\n\n<!--   tidybayes::stat_lineribbon() +  -->\n\n<!--   geom_point(aes(x = bill_length_center, -->\n\n<!--                  y = bill_depth_mm, -->\n\n<!--                  fill = species, colour = species), -->\n\n<!--              data = penguins_no_NA,  -->\n\n<!--              inherit.aes = FALSE) +    -->\n\n<!--   scale_fill_brewer(palette = \"Set2\") + -->\n\n<!--   scale_color_brewer(palette = \"Dark2\") +  -->\n\n<!--   labs(title = \"Average response\") -->\n\n<!-- bill_posterior |>  -->\n\n<!--   ggplot(aes(x = bill_length, -->\n\n<!--              dist = post_bill_dep_obs, -->\n\n<!--              fill = spp, -->\n\n<!--              colour = spp)) +  -->\n\n<!--   tidybayes::stat_lineribbon() +  -->\n\n<!--   geom_point(aes(x = bill_length_center, -->\n\n<!--                  y = bill_depth_mm, -->\n\n<!--                  colour = species), -->\n\n<!--              data = penguins_no_NA,  -->\n\n<!--              inherit.aes = FALSE) +  -->\n\n<!--   scale_fill_brewer(palette = \"Set2\") + -->\n\n<!--   scale_color_brewer(palette = \"Dark2\") +  -->\n\n<!--   labs(title = \"Predicted observations\") +  -->\n\n<!--   facet_wrap(~spp, ncol = 1) -->\n\n<!-- ``` -->\n\n## Exercise!\n\n1.  We have one model without species identity as an independent variable, and one which includes species. Look at the difference in $\\sigma$ between these two models. Why did the value change?\n2.  **Posterior predictions** Compare the model with species identity to the one without it, by performing posterior predictive checks for each of them (e.g. using \\``pp_check(..., type = \"dens_overlay\"))` ) which model do you prefer?\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}